<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Professional Voice Chat</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
    }
    
    .voice-container {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 24px;
      padding: 40px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }
    
    .title {
      text-align: center;
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 30px;
      background: linear-gradient(45deg, #fff, #e0e0e0);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-bottom: 30px;
    }
    
    .btn {
      padding: 16px 32px;
      border: none;
      border-radius: 50px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      min-width: 140px;
    }
    
    .btn-start {
      background: linear-gradient(135deg, #00d4ff, #0099cc);
      color: white;
      box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
    }
    
    .btn-stop {
      background: linear-gradient(135deg, #ff4757, #c44569);
      color: white;
      box-shadow: 0 8px 32px rgba(255, 71, 87, 0.3);
    }
    
    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }
    
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .status-panel {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 24px;
      text-align: center;
      margin-bottom: 30px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .status-text {
      font-size: 1.2rem;
      font-weight: 500;
      margin-bottom: 10px;
    }
    
    .transcription {
      font-size: 0.95rem;
      opacity: 0.8;
      font-style: italic;
      min-height: 20px;
    }
    
    .audio-visualizer {
      height: 80px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      margin-bottom: 30px;
      position: relative;
      overflow: hidden;
      display: none;
    }
    
    .wave-container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      gap: 3px;
    }
    
    .wave-bar {
      width: 4px;
      background: linear-gradient(to top, #00d4ff, #0099cc);
      border-radius: 2px;
      transition: height 0.1s ease;
      height: 10px;
    }
    
    .recording-pulse {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      background: #ff4757;
      border-radius: 50%;
      display: none;
    }
    
    .recording-pulse::before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      border: 2px solid #ff4757;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(2); }
    }
    
    .quality-indicators {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      opacity: 0.7;
    }
    
    .indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .indicator-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #00d4ff;
    }
    
    .vad-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff4757;
      opacity: 0.3;
      transition: opacity 0.1s ease;
    }
    
    .vad-indicator.active {
      opacity: 1;
      background: #00ff88;
    }
    
    @media (max-width: 600px) {
      .voice-container {
        margin: 20px;
        padding: 30px 20px;
      }
      
      .controls {
        flex-direction: column;
      }
      
      .btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="voice-container">
    <h1 class="title">üéôÔ∏è Pro Voice Chat</h1>
    
    <div class="controls">
      <button id="startBtn" class="btn btn-start">‚ñ∂ Start Listening</button>
      <button id="stopBtn" class="btn btn-stop" disabled>‚èπ Stop</button>
    </div>
    
    <div class="status-panel">
      <div id="status" class="status-text">Ready to start voice detection</div>
      <div id="transcription" class="transcription"></div>
    </div>
    
    <div id="visualizer" class="audio-visualizer">
      <div class="vad-indicator" id="vadIndicator"></div>
      <div class="wave-container" id="waveContainer"></div>
      <div class="recording-pulse" id="recordingPulse"></div>
    </div>
    
    <div class="quality-indicators">
      <div class="indicator">
        <div class="indicator-dot"></div>
        <span>48kHz Sampling</span>
      </div>
      <div class="indicator">
        <div class="indicator-dot"></div>
        <span>Smart VAD</span>
      </div>
      <div class="indicator">
        <div class="indicator-dot"></div>
        <span>Auto Recording</span>
      </div>
    </div>
  </div>

  <script>
    class ProfessionalAudioRecorder {
      constructor() {
        this.audioContext = null;
        this.mediaStream = null;
        this.mediaRecorder = null;
        this.analyser = null;
        this.recordedChunks = [];
        this.isListening = false;
        this.isRecording = false;
        this.silenceTimer = null;
        
        // VAD parameters - fine-tuned for better detection
        this.vadThreshold = 0.008; // Lowered threshold for better sensitivity
        this.silenceTimeout = 1500; // Reduced timeout for faster response
        this.minRecordingTime = 500; // Minimum recording time in ms
        this.recordingStartTime = 0;
        
        // Audio analysis
        this.dataArray = null;
        this.bufferLength = 0;
        this.sampleRate = 48000;
        
        // Smoothing for VAD
        this.volumeHistory = [];
        this.historySize = 10;
        
        // UI Elements
        this.startBtn = document.getElementById('startBtn');
        this.stopBtn = document.getElementById('stopBtn');
        this.status = document.getElementById('status');
        this.transcription = document.getElementById('transcription');
        this.visualizer = document.getElementById('visualizer');
        this.waveContainer = document.getElementById('waveContainer');
        this.recordingPulse = document.getElementById('recordingPulse');
        this.vadIndicator = document.getElementById('vadIndicator');
        
        this.setupUI();
        this.createWaveBars();
      }
      
      setupUI() {
        this.startBtn.addEventListener('click', () => this.startListening());
        this.stopBtn.addEventListener('click', () => this.stopListening());
      }
      
      createWaveBars() {
        for (let i = 0; i < 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          this.waveContainer.appendChild(bar);
        }
      }
      
      async startListening() {
        try {
          this.startBtn.disabled = true;
          this.stopBtn.disabled = false;
          this.updateStatus('üé§ Initializing audio system...');
          
          // Get audio stream with optimized settings
          this.mediaStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              sampleRate: this.sampleRate,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              googEchoCancellation: true,
              googAutoGainControl: true,
              googNoiseSuppression: true,
              googHighpassFilter: true
            }
          });
          
          // Create audio context and analyser
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: this.sampleRate
          });
          
          const source = this.audioContext.createMediaStreamSource(this.mediaStream);
          this.analyser = this.audioContext.createAnalyser();
          this.analyser.fftSize = 2048;
          this.analyser.smoothingTimeConstant = 0.8;
          
          source.connect(this.analyser);
          
          this.bufferLength = this.analyser.frequencyBinCount;
          this.dataArray = new Uint8Array(this.bufferLength);
          
          // Setup MediaRecorder for actual recording
          this.setupMediaRecorder();
          
          this.visualizer.style.display = 'block';
          this.isListening = true;
          this.updateStatus('üëÇ Listening for voice... Speak to start recording!');
          
          // Start the VAD loop
          this.vadLoop();
          
        } catch (error) {
          console.error('Error starting listener:', error);
          this.updateStatus(`‚ùå Error: ${error.message}`);
          this.reset();
        }
      }
      
      setupMediaRecorder() {
        this.mediaRecorder = new MediaRecorder(this.mediaStream, {
          mimeType: 'audio/webm;codecs=opus'
        });
        
        this.mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            this.recordedChunks.push(event.data);
          }
        };
        
        this.mediaRecorder.onstop = () => {
          this.processRecordedAudio();
        };
      }
      
      vadLoop() {
        if (!this.isListening) return;
        
        // Get frequency data
        this.analyser.getByteFrequencyData(this.dataArray);
        
        // Calculate RMS (Root Mean Square) for volume detection
        let sum = 0;
        for (let i = 0; i < this.bufferLength; i++) {
          sum += (this.dataArray[i] / 255) * (this.dataArray[i] / 255);
        }
        const rms = Math.sqrt(sum / this.bufferLength);
        
        // Smooth the volume using history
        this.volumeHistory.push(rms);
        if (this.volumeHistory.length > this.historySize) {
          this.volumeHistory.shift();
        }
        
        const avgVolume = this.volumeHistory.reduce((a, b) => a + b, 0) / this.volumeHistory.length;
        
        // Update visualization
        this.updateVisualization(avgVolume);
        
        // Voice Activity Detection
        const voiceDetected = avgVolume > this.vadThreshold;
        
        // Update VAD indicator
        if (voiceDetected) {
          this.vadIndicator.classList.add('active');
        } else {
          this.vadIndicator.classList.remove('active');
        }
        
        // Handle recording state based on voice detection
        if (voiceDetected) {
          if (!this.isRecording) {
            this.startRecording();
          }
          // Clear silence timer since voice is detected
          if (this.silenceTimer) {
            clearTimeout(this.silenceTimer);
            this.silenceTimer = null;
          }
        } else if (this.isRecording) {
          // Start silence timer only if not already running
          if (!this.silenceTimer) {
            this.silenceTimer = setTimeout(() => {
              this.stopRecording();
            }, this.silenceTimeout);
          }
        }
        
        // Continue the loop
        requestAnimationFrame(() => this.vadLoop());
      }
      
      updateVisualization(level) {
        const bars = this.waveContainer.querySelectorAll('.wave-bar');
        const intensity = Math.min(level * 200, 1); // Scale the level
        
        bars.forEach((bar, index) => {
          // Create wave effect with some randomness
          const waveHeight = Math.sin((Date.now() * 0.001) + (index * 0.2)) * intensity * 30;
          const height = Math.max(10, 20 + waveHeight + (Math.random() * intensity * 20));
          bar.style.height = `${height}px`;
        });
      }
      
      startRecording() {
        if (this.isRecording || !this.mediaRecorder) return;
        
        console.log('üî¥ Starting recording...');
        this.isRecording = true;
        this.recordedChunks = [];
        this.recordingStartTime = Date.now();
        
        // UI updates
        this.recordingPulse.style.display = 'block';
        this.updateStatus('üî¥ Recording... Keep speaking!');
        
        // Start MediaRecorder
        this.mediaRecorder.start();
      }
      
      stopRecording() {
        if (!this.isRecording || !this.mediaRecorder) return;
        
        // Check minimum recording time
        const recordingDuration = Date.now() - this.recordingStartTime;
        if (recordingDuration < this.minRecordingTime) {
          console.log('Recording too short, continuing...');
          return;
        }
        
        console.log('‚èπÔ∏è Stopping recording...');
        this.isRecording = false;
        
        // UI updates
        this.recordingPulse.style.display = 'none';
        this.updateStatus('‚ö° Processing audio...');
        
        // Stop MediaRecorder
        this.mediaRecorder.stop();
        
        // Clear silence timer
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
      }
      
      async processRecordedAudio() {
        if (this.recordedChunks.length === 0) {
          this.updateStatus('üëÇ Listening for voice... Speak to start recording!');
          return;
        }
        
        try {
          // Create blob from recorded chunks
          const audioBlob = new Blob(this.recordedChunks, { type: 'audio/webm' });
          
          console.log('üì§ Sending audio to server...');
          
          // Send to server
          const formData = new FormData();
          formData.append('file', audioBlob, 'voice_recording.webm');
          
          const response = await fetch('https://speech-to-speech-1pnl.onrender.com/voicechat', {
            method: 'POST',
            body: formData
          });
          
          if (!response.ok) {
            throw new Error(`Server error: ${response.status} ${response.statusText}`);
          }
          
          // Get transcription from header
          const transcriptionText = response.headers.get('X-Transcript') || 'No transcription available';
          this.transcription.textContent = `"${transcriptionText}"`;
          
          this.updateStatus('üîä Playing response...');
          
          // Play the response audio
          const responseAudioBlob = await response.blob();
          const audio = new Audio(URL.createObjectURL(responseAudioBlob));
          
          audio.onended = () => {
            this.updateStatus('üëÇ Listening for voice... Speak to start recording!');
          };
          
          audio.onerror = (error) => {
            console.error('Audio playback error:', error);
            this.updateStatus('üëÇ Listening for voice... Speak to start recording!');
          };
          
          await audio.play();
          
        } catch (error) {
          console.error('Processing error:', error);
          this.updateStatus(`‚ùå Error: ${error.message}`);
          setTimeout(() => {
            this.updateStatus('üëÇ Listening for voice... Speak to start recording!');
          }, 3000);
        }
        
        // Clear recorded chunks
        this.recordedChunks = [];
      }
      
      updateStatus(message) {
        this.status.textContent = message;
      }
      
      stopListening() {
        console.log('üõë Stopping listener...');
        this.isListening = false;
        
        // Stop any ongoing recording
        if (this.isRecording && this.mediaRecorder && this.mediaRecorder.state === 'recording') {
          this.mediaRecorder.stop();
        }
        
        this.reset();
        this.updateStatus('‚èπÔ∏è Voice detection stopped');
      }
      
      reset() {
        this.startBtn.disabled = false;
        this.stopBtn.disabled = true;
        this.visualizer.style.display = 'none';
        this.recordingPulse.style.display = 'none';
        this.vadIndicator.classList.remove('active');
        
        // Clear timers
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
        
        // Stop media stream
        if (this.mediaStream) {
          this.mediaStream.getTracks().forEach(track => track.stop());
          this.mediaStream = null;
        }
        
        // Close audio context
        if (this.audioContext && this.audioContext.state !== 'closed') {
          this.audioContext.close();
          this.audioContext = null;
        }
        
        // Reset state
        this.isRecording = false;
        this.isListening = false;
        this.recordedChunks = [];
        this.volumeHistory = [];
        this.mediaRecorder = null;
        this.analyser = null;
      }
    }
    
    // Initialize the recorder when page loads
    document.addEventListener('DOMContentLoaded', () => {
      const recorder = new ProfessionalAudioRecorder();
    });
  </script>
</body>
</html>
