<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Voice Chatbot</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 40px auto;
      padding: 0 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
    }
    #chatbox {
      border: 1px solid #ccc;
      padding: 15px;
      height: 350px;
      overflow-y: auto;
      margin-bottom: 15px;
      background: #fafafa;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
    }
    .message {
      margin-bottom: 10px;
      padding: 8px 12px;
      border-radius: 15px;
      max-width: 80%;
      word-wrap: break-word;
    }
    .user-msg {
      background-color: #cce5ff;
      align-self: flex-end;
      margin-left: auto;
    }
    .bot-msg {
      background-color: #e2e2e2;
      align-self: flex-start;
      margin-right: auto;
    }
    #status {
      margin-bottom: 15px;
      font-style: italic;
      text-align: center;
      color: #555;
    }
    button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
      transition: background-color 0.3s ease;
    }
    button:disabled {
      background-color: #7aa7f7;
      cursor: not-allowed;
    }
    button:hover:not(:disabled) {
      background-color: #0056b3;
    }
    #buttons {
      text-align: center;
      margin-bottom: 25px;
    }
  </style>
</head>
<body>
  <h1>Voice Chatbot</h1>
  <div id="chatbox"></div>
  <div id="status">Status: Idle</div>
  <div id="buttons">
    <button id="startCallBtn">Start Call</button>
    <button id="endCallBtn" disabled>End Call</button>
  </div>

<script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
<script>
  const chatbox = document.getElementById('chatbox');
  const statusEl = document.getElementById('status');
  const startCallBtn = document.getElementById('startCallBtn');
  const endCallBtn = document.getElementById('endCallBtn');

  const MIN_RECORD_TIME = 2000;
  const ENERGY_THRESHOLD = 0.01;

  let audioContext;
  let mediaRecorder;
  let audioChunks = [];
  let analyzer;
  let sourceNode;
  let energySum = 0;
  let energyCount = 0;
  let recordingStartTime = 0;
  let isCalling = false;

  function setStatus(text) {
    statusEl.textContent = "Status: " + text;
  }

  function addMessage(text, fromUser = false) {
    const div = document.createElement('div');
    div.classList.add('message');
    div.classList.add(fromUser ? 'user-msg' : 'bot-msg');
    div.textContent = text;
    chatbox.appendChild(div);
    chatbox.scrollTop = chatbox.scrollHeight;
  }

  async function sendAudioToBackend(blob) {
    setStatus("Sending audio to server...");
    try {
      const formData = new FormData();
      formData.append('file', blob, 'audio.webm');

      const response = await fetch('https://chatbot-yowx.onrender.com/chat', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        setStatus("Server error during chat");
        console.error("API error", response.statusText);
        return;
      }

      const data = await response.json();

      if (data.user_text) addMessage(data.user_text, true);
      if (data.reply) addMessage(data.reply, false);
      setStatus("Idle");

      // Play TTS audio from base64
      if (data.tts_audio_base64) {
        const audioSrc = "data:audio/mp3;base64," + data.tts_audio_base64;
        const audio = new Audio(audioSrc);
        audio.play().catch(e => {
          console.warn("Audio playback failed:", e);
        });
      }

    } catch (error) {
      console.error("Error sending audio:", error);
      setStatus("Error sending audio");
    }
  }

  async function startRecording() {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert('getUserMedia not supported on your browser!');
      return;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      sourceNode = audioContext.createMediaStreamSource(stream);

      energySum = 0;
      energyCount = 0;

      analyzer = Meyda.createMeydaAnalyzer({
        audioContext,
        source: sourceNode,
        bufferSize: 512,
        featureExtractors: ['rms'],
        callback: features => {
          if (!features) return;
          energySum += features.rms;
          energyCount++;
        }
      });
      analyzer.start();

      mediaRecorder = new MediaRecorder(stream);
      audioChunks = [];

      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) audioChunks.push(e.data);
      };

      mediaRecorder.onstop = async () => {
        analyzer.stop();

        const avgEnergy = energyCount > 0 ? energySum / energyCount : 0;
        const recordedTime = Date.now() - recordingStartTime;

        if (recordedTime >= MIN_RECORD_TIME && avgEnergy > ENERGY_THRESHOLD) {
          const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
          await sendAudioToBackend(audioBlob);
        } else {
          console.log("Discarded recording due to low energy or too short.");
        }

        audioChunks = [];

        if (isCalling) {
          startRecording();
        }
      };

      mediaRecorder.start();
      recordingStartTime = Date.now();
      setStatus("Recording...");
    } catch (error) {
      console.error("Error accessing microphone:", error);
      setStatus("Microphone access denied or error");
      isCalling = false;
      updateButtons();
    }
  }

  function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    }
    if (analyzer) {
      analyzer.stop();
    }
    if (sourceNode) {
      sourceNode.disconnect();
    }
    if (audioContext) {
      audioContext.suspend();
    }
  }

  async function startCall() {
    try {
      const response = await fetch('https://chatbot-yowx.onrender.com/start_call', { method: 'POST' });
      const data = await response.json();
      setStatus(data.status);
      addMessage("Call started.", false);
      isCalling = true;
      updateButtons();
      await startRecording();
    } catch (error) {
      console.error("Error starting call:", error);
      setStatus("Error starting call");
    }
  }

  async function endCall() {
    try {
      stopRecording();
      const response = await fetch('https://chatbot-yowx.onrender.com/end_call', { method: 'POST' });
      const data = await response.json();
      setStatus(data.status);
      addMessage("Call ended.", false);
      isCalling = false;
      updateButtons();
    } catch (error) {
      console.error("Error ending call:", error);
      setStatus("Error ending call");
    }
  }

  function updateButtons() {
    startCallBtn.disabled = isCalling;
    endCallBtn.disabled = !isCalling;
  }

  startCallBtn.addEventListener('click', () => {
    if (!isCalling) startCall();
  });

  endCallBtn.addEventListener('click', () => {
    if (isCalling) endCall();
  });

  updateButtons();
  setStatus("Idle");
</script>
</body>
</html>
